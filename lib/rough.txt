import 'package:flutter/material.dart';

class StudentSearchDialog extends StatefulWidget {
  final String rollNo;
  final bool isMentorView;
  final String? mentorUserId;

  const StudentSearchDialog({
    Key? key,
    required this.rollNo,
    required this.isMentorView,
    this.mentorUserId,
  }) : super(key: key);

  @override
  State<StudentSearchDialog> createState() => _StudentSearchDialogState();
}

class _StudentSearchDialogState extends State<StudentSearchDialog> {
 final TextEditingController _rollController = TextEditingController();

  // mentor permissions
  bool _loadingMentorRolls = false;
  Set<String> _mentorAllowedRolls = {};

  // found student doc + details
  DocumentReference<Map<String, dynamic>>? _studentRef;
  Map<String, dynamic>? _studentData;
  bool _searching = false;
  String? _error;

  // calendar + attendance
  final DateFormat _idFmt = DateFormat('yyyy-MM-dd');
  DateTime _focusedDay = DateTime.now();
  Set<DateTime> _selectedDays = {};
  bool _loadingAttendance = false;

  // counts
  int _presentCount = 0;
  int _absentCount = 0;

  // per-date status snapshot (for the small list below the calendar)
  final Map<String, String> _statusByDay = {}; // key: yyyy-MM-dd

  @override
  void initState() {
    super.initState();
    if (widget.isMentor) {
      _loadMentorAllowedRolls();
    }
  }

  @override
  void dispose() {
    _rollController.dispose();
    super.dispose();
  }

  // ---------- mentor permission loading ----------
  Future<void> _loadMentorAllowedRolls() async {
    if (!widget.isMentor || widget.mentorUserId == null) return;
    setState(() => _loadingMentorRolls = true);

    try {
      final col = FirebaseFirestore.instance
          .collection('mentors')
          .doc(widget.mentorUserId)
          .collection('assignedStudents');

      final snap = await col.get();
      final allowed = <String>{};

      for (final doc in snap.docs) {
        final data = doc.data();
        final list = List<String>.from(data['selectedRollNos'] ?? []);
        for (final r in list) {
          allowed.add(r.trim().toUpperCase());
        }
      }

      setState(() {
        _mentorAllowedRolls = allowed;
        _loadingMentorRolls = false;
      });
    } catch (e) {
      setState(() {
        _mentorAllowedRolls = {};
        _loadingMentorRolls = false;
      });
      debugPrint('Error loading mentor allowed rolls: $e');
    }
  }

  // ---------- searching ----------
  Future<void> _searchByRoll() async {
    final roll = _rollController.text.trim().toUpperCase();
    if (roll.isEmpty) {
      setState(() => _error = 'Enter roll number to search.');
      return;
    }

    // mentor restriction
    if (widget.isMentor) {
      if (_loadingMentorRolls) {
        setState(() => _error = 'Please wait… loading permission.');
        return;
      }
      if (!_mentorAllowedRolls.contains(roll)) {
        setState(() {
          _error =
              'This roll number is not assigned to you. Please search an assigned student.';
          _studentRef = null;
          _studentData = null;
          _selectedDays.clear();
          _statusByDay.clear();
          _presentCount = 0;
          _absentCount = 0;
        });
        return;
      }
    }

    setState(() {
      _searching = true;
      _error = null;
      _studentRef = null;
      _studentData = null;
      _selectedDays.clear();
      _statusByDay.clear();
      _presentCount = 0;
      _absentCount = 0;
    });

    try {
      // collection group search across all branches/years/sections
      final q = await FirebaseFirestore.instance
          .collectionGroup('students')
          .where('rollNo', isEqualTo: roll)
          .limit(1)
          .get();

      if (q.docs.isEmpty) {
        setState(() {
          _error = 'No student found for $roll';
          _searching = false;
        });
        return;
      }

      final d = q.docs.first;
      setState(() {
        _studentRef = d.reference;
        _studentData = d.data();
        _searching = false;
      });
    } catch (e) {
      setState(() {
        _error = 'Search failed: $e';
        _searching = false;
      });
    }
  }

  // ---------- attendance ----------
  Future<void> _refreshCounts() async {
    if (_studentRef == null) return;
    if (_selectedDays.isEmpty) {
      setState(() {
        _presentCount = 0;
        _absentCount = 0;
        _statusByDay.clear();
      });
      return;
    }

    setState(() {
      _loadingAttendance = true;
      _presentCount = 0;
      _absentCount = 0;
      _statusByDay.clear();
    });

    try {
      int present = 0;
      int absent = 0;

      // To avoid timezone drift, compare by yyyy-MM-dd ids.
      for (final day in _selectedDays) {
        final id = _idFmt.format(day);
        final status = await _readAttendanceForDate(id);
        if (status == null) {
          // no record — do not count (change here if you want to treat missing as Absent)
          _statusByDay[id] = '—';
          continue;
        }
        final norm = _normalizeStatus(status);
        _statusByDay[id] = norm;
        if (norm == 'Present') present++;
        if (norm == 'Absent') absent++;
      }

      setState(() {
        _presentCount = present;
        _absentCount = absent;
        _loadingAttendance = false;
      });
    } catch (e) {
      setState(() {
        _loadingAttendance = false;
        _error = 'Failed to read attendance: $e';
      });
    }
  }

  /// Reads one date from the student's `attendance/{yyyy-MM-dd}` document.
  /// If your project stores attendance differently, adjust this method only.
  Future<dynamic> _readAttendanceForDate(String yyyyMmDd) async {
    final doc =
        await _studentRef!.collection('attendance').doc(yyyyMmDd).get();
    if (!doc.exists) return null;
    final data = doc.data()!;
    // flexible: accept "status": "Present"/"Absent" or "P"/"A" or boolean
    if (data.containsKey('status')) return data['status'];
    if (data.containsKey('present')) return data['present']; // bool
    return null;
  }

  String _normalizeStatus(dynamic raw) {
    if (raw is bool) return raw ? 'Present' : 'Absent';
    final s = raw.toString().trim().toLowerCase();
    if (s == 'present' || s == 'p' || s == '1' || s == 'true') return 'Present';
    if (s == 'absent' || s == 'a' || s == '0' || s == 'false') return 'Absent';
    return '—';
  }

  // ---------- UI helpers ----------
  Widget _buildTopChips() {
    return Row(
      children: [
        _chipStat('Present', _presentCount, Colors.green),
        const SizedBox(width: 8),
        _chipStat('Absent', _absentCount, Colors.red),
        const Spacer(),
        if (_loadingAttendance)
          const Padding(
            padding: EdgeInsets.only(right: 8),
            child: SizedBox(
              width: 18,
              height: 18,
              child: CircularProgressIndicator(strokeWidth: 2),
            ),
          ),
        FilledButton.icon(
          onPressed: _selectedDays.isEmpty ? null : _refreshCounts,
          icon: const Icon(Icons.fact_check),
          label: const Text('Recalculate'),
        ),
      ],
    );
  }

  Widget _chipStat(String label, int count, Color color) {
    return Chip(
      avatar: CircleAvatar(
        backgroundColor: color,
        child: Text(
          '$count',
          style: const TextStyle(color: Colors.white),
        ),
      ),
      label: Text(label),
      side: BorderSide(color: color.withOpacity(.4)),
      backgroundColor: color.withOpacity(.08),
    );
  }

  Widget _buildLeftPane() {
    if (_studentData == null) {
      return const Center(
        child: Text(
          'Search a roll number to view details',
          style: TextStyle(fontSize: 14, color: Colors.black54),
        ),
      );
    }
    final d = _studentData!;
    final name = (d['name'] ?? '').toString();
    final roll = (d['rollNo'] ?? '').toString();
    final dept = (d['department'] ?? '').toString();
    final sec = (d['section'] ?? '').toString();
    final year = (d['endYear'] ?? '').toString();

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Card(
          elevation: 0,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
            side: BorderSide(color: Colors.grey.shade300),
          ),
          child: Padding(
            padding: const EdgeInsets.all(14),
            child: Row(
              children: [
                const CircleAvatar(
                  radius: 28,
                  child: Icon(Icons.person, size: 28),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(name,
                          style: const TextStyle(
                            fontWeight: FontWeight.w600,
                            fontSize: 18,
                          )),
                      const SizedBox(height: 4),
                      Text('Roll No: $roll'),
                      Text('Department: $dept'),
                      Text('Section: $sec'),
                      Text('Batch/End Year: $year'),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
        const SizedBox(height: 10),
        if (widget.isMentor)
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 8),
            decoration: BoxDecoration(
              color: Colors.blue.withOpacity(.08),
              borderRadius: BorderRadius.circular(10),
              border: Border.all(color: Colors.blue.withOpacity(.25)),
            ),
            child: const Row(
              children: [
                Icon(Icons.lock, size: 16, color: Colors.blue),
                SizedBox(width: 6),
                Expanded(
                  child: Text(
                    'Mentor mode: You can search only your assigned students.',
                    style: TextStyle(fontSize: 12),
                  ),
                ),
              ],
            ),
          ),
      ],
    );
  }

Widget _buildRightPane() {
  // ✅ Declare sortedDays before returning the widget tree
  final sortedDays = _selectedDays.toList()
    ..sort((a, b) => a.compareTo(b));

  return Column(
    crossAxisAlignment: CrossAxisAlignment.start,
    children: [
      _buildTopChips(),
      const SizedBox(height: 10),
      Expanded(
        child: Column(
          children: [
            // Calendar
            Card(
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(12),
                side: BorderSide(color: Colors.grey.shade300),
              ),
              elevation: 0,
              child: Padding(
                padding: const EdgeInsets.all(8),
                child: TableCalendar(
                  firstDay: DateTime.utc(2020, 1, 1),
                  lastDay: DateTime.utc(2050, 12, 31),
                  focusedDay: _focusedDay,
                  onPageChanged: (f) => _focusedDay = f,
                  selectedDayPredicate: (day) {
                    return _selectedDays.any((d) =>
                        d.year == day.year &&
                        d.month == day.month &&
                        d.day == day.day);
                  },
                  onDaySelected: (selectedDay, focusedDay) async {
                    setState(() {
                      _focusedDay = focusedDay;
                      // toggle selection
                      final exists = _selectedDays.any((d) =>
                          d.year == selectedDay.year &&
                          d.month == selectedDay.month &&
                          d.day == selectedDay.day);
                      if (exists) {
                        _selectedDays.removeWhere((d) =>
                            d.year == selectedDay.year &&
                            d.month == selectedDay.month &&
                            d.day == selectedDay.day);
                      } else {
                        _selectedDays.add(DateTime(
                            selectedDay.year, selectedDay.month, selectedDay.day));
                      }
                    });
                    await _refreshCounts();
                  },
                  calendarStyle: const CalendarStyle(
                    isTodayHighlighted: true,
                    outsideDaysVisible: false,
                  ),
                  headerStyle: const HeaderStyle(
                    formatButtonVisible: false,
                    titleCentered: true,
                  ),
                ),
              ),
            ),
            const SizedBox(height: 10),
            // Selected dates & statuses
            Expanded(
              child: Card(
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12),
                  side: BorderSide(color: Colors.grey.shade300),
                ),
                elevation: 0,
                child: Padding(
                  padding: const EdgeInsets.all(12),
                  child: _selectedDays.isEmpty
                      ? const Center(
                          child: Text(
                            'Pick one or more days to see status',
                            style: TextStyle(fontSize: 13, color: Colors.black54),
                          ),
                        )
                      : ListView(
                          children: sortedDays.map((d) {
                            final id = _idFmt.format(d);
                            final status = _statusByDay[id] ?? '—';
                            final color = status == 'Present'
                                ? Colors.green
                                : status == 'Absent'
                                    ? Colors.red
                                    : Colors.grey;
                            return ListTile(
                              dense: true,
                              leading: Icon(Icons.event, color: color),
                              title: Text(id),
                              trailing: Text(
                                status,
                                style: TextStyle(
                                  color: color,
                                  fontWeight: FontWeight.w600,
                                ),
                              ),
                            );
                          }).toList(),
                        ),
                ),
              ),
            ),
          ],
        ),
      ),
    ],
  );
}
  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text('Search Results for ${widget.rollNo}'),
      content: SizedBox(
        width: 800,
        height: 500,
        child: Center(
          child: Text("Student details and calendar will go here"),
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text("Close"),
        )
      ],
    );
  }
}
